<!DOCTYPE html>
<html lang="zh-Hant">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ–°åŒ—å¸‚å¤©æ°£é å ±èˆ‡å³æ™‚é›¨é‡</title>

    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.3/font/bootstrap-icons.min.css">

    <!-- å¼•å…¥ Tone.js ç”¨æ–¼æ’­æ”¾éŸ³æ•ˆ -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.7.77/Tone.js"></script>

    <style>
        body {
            background-color: #f8f9fa;
        }

        #app {
            max-width: 1200px;
            margin: auto;
            padding: 1rem;
        }

        .location-section {
            background-color: white;
            padding: 2rem;
            border-radius: 0.5rem;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.05);
        }

        .chart-container,
        .rain-chart-container {
            position: relative;
            height: 40vh;
            min-height: 300px;
        }

        /* å³æ™‚é›¨é‡å¡ç‰‡æ¨£å¼ */
        .realtime-rain-card {
            background-color: #ffffff;
            border: 1px solid #dee2e6;
            border-radius: 0.375rem;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
        }

        /* ç„¦é»å¼•å°æ¨£å¼ */
        .tour-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background-color: rgba(0, 0, 0, 0.4);
            backdrop-filter: grayscale(80%) blur(2px);
            z-index: 9998;
        }

        .tour-highlight-focus {
            position: relative;
            z-index: 9999;
            box-shadow: 0 0 0 10px rgba(255, 255, 255, 0.7);
            border-radius: 5px;
            animation: pulse 1.5s infinite;
        }

        .tour-tooltip {
            position: absolute;
            background-color: white;
            padding: 1rem;
            border-radius: 5px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            z-index: 10000;
            max-width: 300px;
        }

        /* å…¬å…±è­¦ç¤ºæ¨£å¼ */
        .public-alert-card {
            border-left: 5px solid #dc3545;
            background-color: #fff5f5;
        }

        @keyframes pulse {
            0% {
                box-shadow: 0 0 0 0px rgba(255, 255, 255, 0.7);
            }

            70% {
                box-shadow: 0 0 0 15px rgba(255, 255, 255, 0);
            }

            100% {
                box-shadow: 0 0 0 0px rgba(255, 255, 255, 0);
            }
        }
    </style>
</head>

<body>
    <div id="app">
        <!-- ç„¦é»å¼•å°é®ç½© -->
        <div v-if="showOnboarding" class="tour-overlay" @click="closeTour"></div>

        <!-- ç„¦é»å¼•å°æç¤ºæ¡† -->
        <div v-if="showOnboarding" class="tour-tooltip" :style="tooltipStyle">
            <strong>å•Ÿç”¨è²éŸ³è­¦ç¤º</strong>
            <p class="mb-0 small text-muted mt-2">
                è«‹é»æ“Šæ­¤æŒ‰éˆ•ï¼Œä»¥å…è¨±ç€è¦½å™¨æ’­æ”¾å³æ™‚è­¦ç¤ºéŸ³æ•ˆèˆ‡èªéŸ³ã€‚
            </p>
            <small class="text-muted d-block mt-2">(é»æ“Šä»»æ„ç°è‰²å€åŸŸå¯é—œé–‰æç¤º)</small>
        </div>

        <div class="app-content">
            <header class="text-center my-4">
                <h1 class="display-5 fw-bold">ğŸ™ï¸ æ–°åŒ—å¸‚å¤©æ°£é å ±èˆ‡å³æ™‚é›¨é‡</h1>
                <p class="text-muted">ï¼ˆæ–°åº—å€ã€ä¸­å’Œå€ã€æ¿æ©‹å€é å ±ï½œæ–°åŒ—ã€ä¸­å’Œã€æ¿æ©‹è§€æ¸¬ç«™å³æ™‚è³‡æ–™ï¼‰</p>
                <!-- å•Ÿç”¨éŸ³è¨ŠæŒ‰éˆ• -->
                <button v-if="!isAudioEnabled" ref="enableAudioButtonRef" class="btn btn-info btn-sm"
                    :class="{ 'tour-highlight-focus': showOnboarding }" @click="enableAudio">
                    <i class="bi bi-bell-fill"></i> å•Ÿç”¨è²éŸ³è­¦ç¤º
                </button>
                <span v-if="isAudioEnabled" class="text-success small"><i class="bi bi-check-circle-fill"></i>
                    è²éŸ³å·²å•Ÿç”¨</span>
                <small v-if="!isAudioEnabled && !showOnboarding" class="text-center text-muted d-block mt-2">*
                    è«‹é»æ“Šã€Œå•Ÿç”¨è²éŸ³è­¦ç¤ºã€ä»¥å…è¨±ç€è¦½å™¨æ’­æ”¾å³æ™‚è­¦ç¤ºéŸ³æ•ˆèˆ‡èªéŸ³ã€‚</small>
            </header>

            <div v-if="isLoading" class="text-center my-5">
                <div class="spinner-border text-primary" role="status">
                    <span class="visually-hidden">Loading...</span>
                </div>
                <p class="mt-2">æ­£åœ¨è¼‰å…¥å¤©æ°£è³‡æ–™...</p>
            </div>

            <div v-if="error" class="alert alert-danger" role="alert">
                <i class="bi bi-exclamation-triangle-fill"></i>
                <strong>è³‡æ–™è¼‰å…¥å¤±æ•—ï¼š</strong> {{ error }}
            </div>

            <main v-if="!isLoading && !error" class="d-flex flex-column gap-4">

                <!-- ã€*** æ–°å¢ ***ã€‘ Google å…¬å…±è­¦ç¤ºå€å¡Š -->
                <section v-if="publicAlerts.length > 0">
                    <h2 class="text-center mb-3">âš ï¸ æ”¿åºœå…¬å…±è­¦ç¤º</h2>
                    <div v-for="alert in publicAlerts" :key="alert.id" class="card public-alert-card mb-3 shadow-sm">
                        <div class="card-body">
                            <h5 class="card-title text-danger"><i class="bi bi-exclamation-triangle-fill"></i> {{
                                alert.headline }}</h5>
                            <p class="card-text">{{ alert.description }}</p>
                            <hr>
                            <div class="d-flex justify-content-between">
                                <small class="text-muted">ç™¼å¸ƒæ©Ÿæ§‹ï¼š{{ alert.instruction || 'æ°£è±¡ç½²/æ”¿åºœæ©Ÿæ§‹' }}</small>
                                <small class="text-muted">æœ‰æ•ˆæœŸè‡³ï¼š{{ formatFullDateTime(alert.expiryTime) }}</small>
                            </div>
                        </div>
                    </div>
                </section>

                <!-- å³æ™‚é›¨é‡è§€æ¸¬å€å¡Š -->
                <section>
                    <h2 class="text-center mb-3">ğŸ’§ å³æ™‚é›¨é‡è§€æ¸¬</h2>

                    <!-- å³æ™‚é™é›¨è­¦ç¤º -->
                    <div v-if="immediateAlertMessage" class="alert alert-danger alert-dismissible fade show mt-3"
                        role="alert" style="max-width: 800px; margin-left: auto; margin-right: auto;">
                        <i class="bi bi-exclamation-triangle-fill me-2"></i>
                        <strong>å³æ™‚é™é›¨è­¦ç¤ºï¼š</strong> {{ immediateAlertMessage }}
                        <button type="button" class="btn-close" @click="clearImmediateAlert"></button>
                    </div>

                    <p class="text-center text-primary fw-bold" v-if="rainObservation.length > 0">
                        <i class="bi bi-arrow-clockwise"></i>
                        APIè³‡æ–™æ¯10åˆ†é˜æ›´æ–°ï¼Œå°‡æ–¼ {{ rainCountdownMinutes }} åˆ† {{ rainCountdownSeconds }} ç§’å¾Œæ›´æ–°å³æ™‚è³‡æ–™...
                    </p>
                    <div v-if="rainObservation.length > 0" class="row g-4">
                        <div v-for="station in rainObservation" :key="station.StationId" class="col-md-4">
                            <div class="p-3 realtime-rain-card h-100 d-flex flex-column">
                                <h5 class="mb-3">{{ station.TownName }}</h5>
                                <ul class="list-group list-group-flush flex-grow-1">
                                    <li class="list-group-item d-flex justify-content-between align-items-center">
                                        10åˆ†é˜é›¨é‡
                                        <span class="badge bg-primary rounded-pill fs-6">{{ station.Past10Min }}
                                            mm</span>
                                    </li>
                                    <li class="list-group-item d-flex justify-content-between align-items-center">
                                        1å°æ™‚é›¨é‡
                                        <span class="badge bg-secondary rounded-pill fs-6">{{ station.Past1hr }}
                                            mm</span>
                                    </li>
                                    <li class="list-group-item d-flex justify-content-between align-items-center">
                                        24å°æ™‚é›¨é‡
                                        <span class="badge bg-secondary rounded-pill fs-6">{{ station.Past24hr }}
                                            mm</span>
                                    </li>
                                </ul>
                                <small class="text-muted mt-3 d-block text-center">
                                    è§€æ¸¬æ™‚é–“: {{ formatFullDateTime(station.ObsTime) }}
                                </small>
                            </div>
                        </div>
                    </div>
                </section>

                <!-- å¤©æ°£é å ±å€å¡Š -->
                <section class="location-section">
                    <h2 class="text-center mb-3">ğŸŒ¦ï¸ æœªä¾†24å°æ™‚å¤©æ°£é å ±</h2>

                    <!-- é™é›¨é å ±è­¦ç¤º -->
                    <div v-if="forecastAlertMessage" class="alert alert-warning alert-dismissible fade show mt-3"
                        role="alert" style="max-width: 800px; margin-left: auto; margin-right: auto;">
                        <i class="bi bi-clock-fill me-2"></i>
                        <strong>é™é›¨é å ±è­¦ç¤ºï¼š</strong> {{ forecastAlertMessage }}
                        <button type="button" class="btn-close" @click="clearForecastAlert"></button>
                    </div>

                    <!-- å€’æ•¸è¨ˆæ™‚å™¨ -->
                    <p class="text-center text-success fw-bold" v-if="!isLoading && !error">
                        <i class="bi bi-arrow-clockwise"></i>
                        é å ±å°‡æ–¼ {{ countdownMinutes }} åˆ† {{ countdownSeconds }} ç§’å¾Œè‡ªå‹•æ›´æ–°...
                    </p>

                    <div class="d-flex justify-content-center align-items-center mt-2 gap-2">
                        æ¯ <input type="number" class="form-control" v-model.number="newCountdownValue" min="1"
                            placeholder="ç§’æ•¸" style="width: 100px;"> ç§’æ›´æ–°é å ±
                        <button class="btn btn-secondary btn-sm" @click="applyNewCountdown">è¨­å®š</button>
                    </div>

                    <div v-for="location in locations" :key="location.name" class="mt-5">
                        <h3 class="mb-4 display-6 border-bottom pb-2">{{ location.name }}</h3>
                        <div class="row">
                            <div class="col-lg-4">
                                <h4 class="h5 text-muted">é™é›¨è¶¨å‹¢</h4>
                                <div class="rain-chart-container mb-5">
                                    <canvas :id="'rain-chart-' + location.name"></canvas>
                                </div>
                            </div>
                            <div class="col-lg-8">
                                <h4 class="h5 text-muted">ç¶œåˆå¤©æ°£è¶¨å‹¢</h4>
                                <div class="chart-container mb-5">
                                    <canvas :id="'chart-' + location.name"></canvas>
                                </div>
                            </div>
                        </div>
                    </div>
                </section>
            </main>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/vue@3/dist/vue.global.prod.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

    <script>
        const { createApp } = Vue;

        window.app = createApp({
            data() {
                return {
                    // API è¨­å®š
                    forecastApiUrl: 'https://opendata.cwa.gov.tw/api/v1/rest/datastore/F-D0047-069?Authorization=CWA-F36D4CE9-10F1-43BA-82E6-8E7DA63697F7&format=JSON&LocationName=æ–°åº—å€,ä¸­å’Œå€,æ¿æ©‹å€&ElementName=3å°æ™‚é™é›¨æ©Ÿç‡,æº«åº¦,å¤©æ°£ç¾è±¡,é«”æ„Ÿæº«åº¦',
                    rainApiUrl: 'https://opendata.cwa.gov.tw/api/v1/rest/datastore/O-A0002-001?Authorization=CWA-F36D4CE9-10F1-43BA-82E6-8E7DA63697F7&format=JSON&StationId=466881,C0AG80,C0AJ80',

                    // ã€*** æ–°å¢ ***ã€‘ Google Public Alerts API
                    googleApiKey: "AIzaSyD0JGsX0tr2UZftja1xwavIAMydoB5WkkE", // è«‹åœ¨æ­¤å¡«å…¥æ‚¨çš„ API Key
                    publicAlerts: [],
                    seenAlertIds: new Set(),
                    lastAlertCheck: null,

                    isLoading: true,
                    error: null,
                    showOnboarding: true,
                    tooltipStyle: { top: '0px', left: '0px' },

                    locations: [],
                    chartInstances: {},
                    rainChartInstances: {},
                    rainObservation: [],
                    rainCountdown: 600,
                    countdown: 3600,
                    dataInterval: null,
                    rainInterval: null,
                    alertInterval: null,
                    newCountdownValue: 3600,
                    activeCountdownSetting: 3600,

                    isAudioEnabled: false,
                    immediateAlertMessage: null,
                    forecastAlertMessage: null,
                    previousRain10Min: {},
                    selectedVoice: null,
                    rainLevelsText: ['ç„¡é›¨', 'å°é›¨', 'ä¸­é›¨', 'å¤§é›¨', 'æš´é›¨'],
                };
            },
            computed: {
                countdownMinutes() { return Math.floor(this.countdown / 60); },
                countdownSeconds() { return (this.countdown % 60).toString().padStart(2, '0'); },
                rainCountdownMinutes() { return Math.floor(this.rainCountdown / 60); },
                rainCountdownSeconds() { return (this.rainCountdown % 60).toString().padStart(2, '0'); }
            },
            methods: {
                // --- ã€*** æ–°å¢ ***ã€‘ ç²å– Google å…¬å…±è­¦ç¤º ---
                async fetchPublicAlerts() {
                    if (!this.googleApiKey) return;

                    // ä½¿ç”¨æ–°åº—å€åº§æ¨™ (ç·¯åº¦ 24.96, ç¶“åº¦ 121.52)
                    const lat = 24.960990;
                    const lng = 121.516970;
                    const url = `https://weather.googleapis.com/v1/publicAlerts:lookup?key=${this.googleApiKey}&location.latitude=${lat}&location.longitude=${lng}&languageCode=zh-TW`;
                    // https://weather.googleapis.com/v1/publicAlerts:lookup?key=AIzaSyD0JGsX0tr2UZftja1xwavIAMydoB5WkkE&location.latitude=24.960990&location.longitude=121.516970&languageCode=zh-TW
                    try {
                        const response = await axios.get(url);
                        const alerts = response.data.publicAlerts || [];

                        this.publicAlerts = alerts.map(a => ({
                            id: a.alertId,
                            headline: a.headline,
                            description: a.description,
                            instruction: a.instruction,
                            expiryTime: a.expireTime
                        }));

                        this.checkPublicAlertsTrigger(this.publicAlerts);
                    } catch (err) {
                        console.error("Google Public Alerts è«‹æ±‚å¤±æ•—:", err);
                    }
                },

                checkPublicAlertsTrigger(alerts) {
                    if (!this.isAudioEnabled || alerts.length === 0) return;

                    let newAlertFound = false;
                    let alertSummary = "";

                    alerts.forEach(alert => {
                        if (!this.seenAlertIds.has(alert.id)) {
                            newAlertFound = true;
                            this.seenAlertIds.add(alert.id);
                            alertSummary += alert.headline + "ã€‚";
                        }
                    });

                    if (newAlertFound) {
                        this.playAlertSound();
                        setTimeout(() => {
                            this.speakAlert("ç™¼å¸ƒæ”¿åºœç·Šæ€¥è­¦ç¤ºï¼š" + alertSummary);
                        }, 2000);
                    }
                },

                async fetchWeatherData() {
                    this.countdown = this.activeCountdownSetting;
                    try {
                        const response = await axios.get(this.forecastApiUrl);
                        if (response.data.success !== "true") throw new Error('API å›æ‡‰éŒ¯èª¤');
                        this.processData(response.data);
                        this.checkRainAlert(this.locations);
                        this.$nextTick(() => { this.$nextTick(() => { this.renderAllCharts(); }); });
                    } catch (err) {
                        this.error = "ç„¡æ³•ç²å–å¤©æ°£é å ±è³‡æ–™ã€‚";
                    } finally { this.isLoading = false; }
                },

                async fetchRainObservation() {
                    this.rainCountdown = 600;
                    try {
                        if (this.rainObservation.length > 0) {
                            this.rainObservation.forEach(station => {
                                this.previousRain10Min[station.StationId] = parseFloat(station.Past10Min);
                            });
                        }
                        const response = await axios.get(this.rainApiUrl);
                        if (response.data.success !== "true") throw new Error('é›¨é‡ API éŒ¯èª¤');
                        this.rainObservation = response.data.records.Station.map(station => ({
                            StationName: station.StationName,
                            StationId: station.StationId,
                            TownName: station.GeoInfo.TownName,
                            ObsTime: station.ObsTime.DateTime,
                            Past10Min: station.RainfallElement.Past10Min.Precipitation,
                            Past1hr: station.RainfallElement.Past1hr.Precipitation,
                            Past24hr: station.RainfallElement.Past24hr.Precipitation,
                        }));
                        this.checkImmediateRainAlert(this.rainObservation);
                    } catch (err) { console.error(err); }
                },

                processData(data) {
                    const currentTime = new Date();
                    const rawLocations = data.records.Locations[0].Location;
                    this.locations = rawLocations.map(location => {
                        const tempElement = location.WeatherElement.find(el => el.ElementName === 'æº«åº¦').Time;
                        const apparentTempElement = location.WeatherElement.find(el => el.ElementName === 'é«”æ„Ÿæº«åº¦').Time;
                        const popElement = location.WeatherElement.find(el => el.ElementName === '3å°æ™‚é™é›¨æ©Ÿç‡').Time;
                        const weatherElement = location.WeatherElement.find(el => el.ElementName === 'å¤©æ°£ç¾è±¡').Time;
                        const forecasts = popElement.map(popTime => {
                            const startTime = popTime.StartTime;
                            const currentTemp = tempElement.find(t => t.DataTime === startTime);
                            const currentApparentTemp = apparentTempElement.find(t => t.DataTime === startTime);
                            const currentWx = weatherElement.find(wx => wx.StartTime === startTime);
                            return {
                                startTime,
                                pop: popTime.ElementValue[0].ProbabilityOfPrecipitation,
                                temp: currentTemp ? currentTemp.ElementValue[0].Temperature : 'N/A',
                                apparentTemp: currentApparentTemp ? currentApparentTemp.ElementValue[0].ApparentTemperature : 'N/A',
                                weather: currentWx ? currentWx.ElementValue[0].Weather : 'N/A',
                                rainLevel: this.getRainLevel(currentWx ? currentWx.ElementValue[0].WeatherCode : '0')
                            };
                        }).filter(f => new Date(f.startTime) >= currentTime);
                        return { name: location.LocationName, forecasts };
                    });
                },

                renderAllCharts() {
                    this.locations.forEach(location => {
                        this.renderWeatherChart(location);
                        this.renderRainChart(location);
                    });
                },

                renderWeatherChart(location) {
                    const canvasId = 'chart-' + location.name;
                    const ctx = document.getElementById(canvasId);
                    if (!ctx) return;
                    if (this.chartInstances[location.name]) this.chartInstances[location.name].destroy();
                    this.chartInstances[location.name] = new Chart(ctx, {
                        type: 'bar',
                        data: {
                            labels: location.forecasts.map(f => this.formatTime(f.startTime)),
                            datasets: [
                                { type: 'line', label: 'æº«åº¦ (Â°C)', data: location.forecasts.map(f => f.temp), borderColor: 'red', yAxisID: 'y-temp' },
                                { type: 'bar', label: 'é™é›¨æ©Ÿç‡ (%)', data: location.forecasts.map(f => f.pop), backgroundColor: 'rgba(54, 162, 235, 0.5)', yAxisID: 'y-pop' }
                            ]
                        },
                        options: { scales: { 'y-temp': { position: 'left' }, 'y-pop': { position: 'right', max: 100 } } }
                    });
                },

                renderRainChart(location) {
                    const canvasId = 'rain-chart-' + location.name;
                    const ctx = document.getElementById(canvasId);
                    if (!ctx) return;
                    if (this.rainChartInstances[location.name]) this.rainChartInstances[location.name].destroy();
                    this.rainChartInstances[location.name] = new Chart(ctx, {
                        type: 'line',
                        data: {
                            labels: location.forecasts.slice(0, 8).map(f => this.formatTime(f.startTime)),
                            datasets: [{ label: 'é™é›¨ç­‰ç´š', data: location.forecasts.slice(0, 8).map(f => f.rainLevel), stepped: true, fill: true }]
                        },
                        options: { scales: { y: { min: 0, max: 4, ticks: { stepSize: 1, callback: v => this.rainLevelsText[v] } } } }
                    });
                },

                enableAudio() {
                    Tone.start().then(() => {
                        this.isAudioEnabled = true;
                        this.loadSpeechVoices();
                        this.playAlertSound();
                        this.closeTour();
                    });
                },

                loadSpeechVoices() {
                    speechSynthesis.onvoiceschanged = () => {
                        const voices = speechSynthesis.getVoices();
                        this.selectedVoice = voices.find(v => v.name === 'Google ä¸­æ–‡ (è‡ºç£)') || voices.find(v => v.lang === 'zh-TW');
                    };
                },

                playAlertSound() {
                    if (!this.isAudioEnabled) return;
                    const synth = new Tone.Synth().toDestination();
                    const now = Tone.now();
                    synth.triggerAttackRelease("C5", "16n", now);
                    synth.triggerAttackRelease("C5", "16n", now + 0.15);
                    synth.triggerAttackRelease("C5", "16n", now + 0.3);
                },

                speakAlert(message) {
                    if (!this.isAudioEnabled || !this.selectedVoice) return;
                    window.speechSynthesis.cancel();
                    const utterance = new SpeechSynthesisUtterance(message);
                    utterance.voice = this.selectedVoice;
                    window.speechSynthesis.speak(utterance);
                },

                checkImmediateRainAlert(observations) {
                    if (!this.isAudioEnabled) return;
                    let msgs = [];
                    observations.forEach(s => {
                        const curr = parseFloat(s.Past10Min);
                        const prev = this.previousRain10Min[s.StationId] || 0;
                        if (curr >= 0.5 && prev < 0.5) msgs.push(`${s.TownName}ç«™ 10åˆ†é˜é›¨é‡é” ${curr}mmã€‚`);
                    });
                    if (msgs.length > 0) {
                        this.immediateAlertMessage = msgs.join(' ');
                        this.playAlertSound();
                        setTimeout(() => this.speakAlert("å³æ™‚é›¨é‡è­¦ç¤ºï¼š" + this.immediateAlertMessage), 1000);
                    } else { this.immediateAlertMessage = null; }
                },

                checkRainAlert(locations) {
                    if (!this.isAudioEnabled || this.immediateAlertMessage) return;
                    let msgs = [];
                    locations.forEach(l => {
                        const curr = l.forecasts[0]?.rainLevel || 0;
                        const next = l.forecasts[1]?.rainLevel || 0;
                        if (next > curr) msgs.push(`${l.name}é è¨ˆé›¨å‹¢å¢å¼·ç‚º${this.rainLevelsText[next]}ã€‚`);
                    });
                    if (msgs.length > 0) {
                        this.forecastAlertMessage = msgs.join(' ');
                        this.playAlertSound();
                        setTimeout(() => this.speakAlert("é™é›¨é å ±è­¦ç¤ºï¼š" + this.forecastAlertMessage), 5000);
                    } else { this.forecastAlertMessage = null; }
                },

                getRainLevel(code) {
                    const c = parseInt(code);
                    if (c === 41) return 4;
                    if ([33, 34, 35, 36, 39, 42].includes(c)) return 3;
                    if ([13, 14, 15, 16, 17, 18, 21, 22].includes(c)) return 2;
                    if ([8, 9, 10, 11, 12, 19, 20, 29, 30, 31, 32].includes(c)) return 1;
                    return 0;
                },

                formatTime: s => new Date(s).toLocaleTimeString('zh-TW', { hour: '2-digit', minute: '2-digit', hour12: false }),
                formatFullDateTime: s => new Date(s).toLocaleString('zh-TW', { month: '2-digit', day: '2-digit', hour: '2-digit', minute: '2-digit', hour12: false }),

                applyNewCountdown() {
                    this.countdown = this.newCountdownValue;
                    clearInterval(this.dataInterval);
                    this.dataInterval = setInterval(() => this.fetchWeatherData(), this.countdown * 1000);
                },

                startTour() {
                    this.$nextTick(() => {
                        const rect = this.$refs.enableAudioButtonRef?.getBoundingClientRect();
                        if (rect) this.tooltipStyle = { top: (rect.bottom + 15) + 'px', left: rect.left + 'px' };
                    });
                },
                closeTour() { this.showOnboarding = false; },
                clearImmediateAlert() { this.immediateAlertMessage = null; window.speechSynthesis.cancel(); },
                clearForecastAlert() { this.forecastAlertMessage = null; window.speechSynthesis.cancel(); }
            },
            mounted() {
                this.startTour();
                this.fetchWeatherData();
                this.fetchRainObservation();
                this.fetchPublicAlerts(); // åˆå§‹æŠ“å–å…¬å…±è­¦ç¤º

                setInterval(() => { if (this.countdown > 0) this.countdown--; }, 1000);
                setInterval(() => { if (this.rainCountdown > 0) this.rainCountdown--; }, 1000);

                this.dataInterval = setInterval(() => this.fetchWeatherData(), this.activeCountdownSetting * 1000);
                this.rainInterval = setInterval(() => this.fetchRainObservation(), 600000);
                this.alertInterval = setInterval(() => this.fetchPublicAlerts(), 1800000); // 30åˆ†é˜æ›´æ–°ä¸€æ¬¡å…¬å…±è­¦ç¤º
            }
        }).mount('#app');
    </script>
</body>

</html>