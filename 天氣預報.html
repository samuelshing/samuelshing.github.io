<!DOCTYPE html>
<html lang="zh-Hant">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å¤©æ°£é å ±</title>

    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.3/font/bootstrap-icons.min.css">

    <style>
        body {
            background-color: #f8f9fa;
        }

        #app {
            max-width: 960px;
            margin: auto;
            padding: 1rem;
        }

        .chart-container {
            position: relative;
            height: 40vh;
            min-height: 300px;
        }

        .weather-card {
            transition: transform 0.2s;
        }

        .weather-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
        }

        .weather-icon {
            font-size: 3rem;
            color: #0d6efd;
        }
    </style>
</head>

<body>

    <div id="app">
        <header class="text-center my-4">
            <h1 class="display-5 fw-bold">ğŸ™ï¸ æ–°åŒ—å¸‚å¤©æ°£é å ±</h1>
            <p class="text-muted">æ¿æ©‹ã€ä¸­å’Œã€æ–°åº—å€æœªä¾†3æ—¥ä¹‹3å°æ™‚é™é›¨æ©Ÿç‡,æº«åº¦,å¤©æ°£ç¾è±¡,é«”æ„Ÿæº«åº¦</p>
        </header>

        <div v-if="isLoading" class="text-center my-5">
            <div class="spinner-border text-primary" role="status">
                <span class="visually-hidden">Loading...</span>
            </div>
            <p class="mt-2">æ­£åœ¨è¼‰å…¥å¤©æ°£è³‡æ–™...</p>
        </div>

        <div v-if="error" class="alert alert-danger" role="alert">
            <i class="bi bi-exclamation-triangle-fill"></i>
            <strong>è³‡æ–™è¼‰å…¥å¤±æ•—ï¼š</strong> {{ error }}
        </div>

        <main v-if="!isLoading && !error">
            <div class="mb-4">
                <label for="locationSelector" class="form-label">é¸æ“‡åœ°å€ï¼š</label>
                <select id="locationSelector" class="form-select form-select-lg" v-model="selectedLocation">
                    <option v-for="loc in locations" :key="loc.name" :value="loc.name">{{ loc.name }}</option>
                </select>
            </div>

            <section class="chart-container mb-5">
                <canvas id="weatherChart"></canvas>
            </section>

            <section>
                <h3 class="mb-3"><i class="bi bi-card-list"></i> è©³ç´°é å ±</h3>
                <div class="row g-3">
                    <div v-for="forecast in currentLocationData.forecasts" :key="forecast.startTime"
                        class="col-12 col-md-6 col-lg-4">
                        <div class="card h-100 weather-card">
                            <div class="card-body">
                                <div class="d-flex justify-content-between align-items-center">
                                    <div>
                                        <h5 class="card-title">{{ formatTime(forecast.startTime) }} - {{
                                            formatTime(forecast.endTime) }}</h5>
                                        <h6 class="card-subtitle mb-2 text-muted">{{ formatDate(forecast.startTime) }}
                                        </h6>
                                    </div>
                                    <i :class="getWeatherIconClass(forecast.weatherCode)" class="weather-icon"></i>
                                </div>
                                <p class="card-text fs-5 my-2">{{ forecast.weather }}</p>
                                <ul class="list-group list-group-flush">
                                    <li class="list-group-item d-flex justify-content-between">
                                        <span><i class="bi bi-thermometer-half text-danger"></i> æº«åº¦</span>
                                        <strong>{{ forecast.temp }} Â°C</strong>
                                    </li>
                                    <li class="list-group-item d-flex justify-content-between">
                                        <span><i class="bi bi-person text-info"></i> é«”æ„Ÿ</span>
                                        <strong>{{ forecast.apparentTemp }} Â°C</strong>
                                    </li>
                                    <li class="list-group-item d-flex justify-content-between">
                                        <span><i class="bi bi-cloud-drizzle-fill text-primary"></i> é™é›¨æ©Ÿç‡</span>
                                        <strong>{{ forecast.pop }} %</strong>
                                    </li>
                                </ul>
                            </div>
                        </div>
                    </div>
                </div>
            </section>
        </main>

        <footer class="text-center text-muted mt-5">
            <p>è³‡æ–™ä¾†æºï¼š<a href="https://opendata.cwa.gov.tw/" target="_blank">äº¤é€šéƒ¨ä¸­å¤®æ°£è±¡ç½²</a></p>
        </footer>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/vue@3/dist/vue.global.prod.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

    <script>
        const { createApp } = Vue;

        createApp({
            data() {
                return {
                    // æ³¨æ„ï¼šAPIæˆæ¬Šç¢¼ (Authorization) å¯èƒ½æœ‰æ™‚æ•ˆæ€§ï¼Œè‹¥å¤±æ•ˆè«‹è‡³æ°£è±¡ç½²å®˜ç¶²ç”³è«‹æ–°çš„
                    apiUrl: 'https://opendata.cwa.gov.tw/api/v1/rest/datastore/F-D0047-069?Authorization=CWA-F36D4CE9-10F1-43BA-82E6-8E7DA63697F7&format=JSON&LocationName=æ–°åº—å€,ä¸­å’Œå€,æ¿æ©‹å€&ElementName=3å°æ™‚é™é›¨æ©Ÿç‡,æº«åº¦,å¤©æ°£ç¾è±¡,é«”æ„Ÿæº«åº¦',
                    isLoading: true,
                    error: null,
                    locations: [],
                    selectedLocation: '',
                    chartInstance: null
                };
            },
            computed: {
                currentLocationData() {
                    return this.locations.find(loc => loc.name === this.selectedLocation) || { forecasts: [] };
                }
            },
            watch: {
                selectedLocation() {
                    // ç­‰å¾… Vue å°‡ç•«é¢æ›´æ–°å®Œç•¢å¾Œï¼Œå†åŸ·è¡Œæ¸²æŸ“åœ–è¡¨çš„å‡½å¼
                    this.$nextTick(() => {
                        this.renderChart();
                    });
                }
            },
            methods: {
                async fetchWeatherData() {
                    this.isLoading = true;
                    this.error = null;
                    try {
                        // ä½¿ç”¨ Axios å–å¾— API è³‡æ–™
                        const response = await axios.get(this.apiUrl);
                        if (response.data.success !== "true") {
                            throw new Error('API å›æ‡‰éŒ¯èª¤');
                        }
                        this.processData(response.data);
                        if (this.locations.length > 0) {
                            this.selectedLocation = this.locations[0].name; // é è¨­é¸æ“‡ç¬¬ä¸€å€‹åœ°å€
                        }
                    } catch (err) {
                        console.error("API è«‹æ±‚å¤±æ•—:", err);
                        this.error = "ç„¡æ³•å¾ä¸­å¤®æ°£è±¡ç½²ä¼ºæœå™¨ç²å–è³‡æ–™ï¼Œè«‹ç¨å¾Œå†è©¦ã€‚";
                    } finally {
                        this.isLoading = false;
                    }
                },
                processData(data) {
                    const rawLocations = data.records.Locations[0].Location;
                    const processedLocations = rawLocations.map(location => {
                        // å–å¾—å„å¤©æ°£å…ƒç´ çš„è³‡æ–™é™£åˆ—
                        const tempElement = location.WeatherElement.find(el => el.ElementName === 'æº«åº¦').Time;
                        const apparentTempElement = location.WeatherElement.find(el => el.ElementName === 'é«”æ„Ÿæº«åº¦').Time;
                        const popElement = location.WeatherElement.find(el => el.ElementName === '3å°æ™‚é™é›¨æ©Ÿç‡').Time;
                        const weatherElement = location.WeatherElement.find(el => el.ElementName === 'å¤©æ°£ç¾è±¡').Time;

                        // ä»¥3å°æ™‚é™é›¨æ©Ÿç‡çš„æ™‚é–“å€é–“ç‚ºåŸºæº–ï¼Œåˆä½µæ‰€æœ‰è³‡æ–™
                        const forecasts = popElement.map(popTime => {
                            const startTime = popTime.StartTime;

                            // å°‹æ‰¾å°æ‡‰æ™‚é–“é»çš„æº«åº¦è³‡æ–™
                            const currentTemp = tempElement.find(t => t.DataTime === startTime);
                            const currentApparentTemp = apparentTempElement.find(t => t.DataTime === startTime);
                            const currentWx = weatherElement.find(wx => wx.StartTime === startTime);

                            return {
                                startTime: startTime,
                                endTime: popTime.EndTime,
                                pop: popTime.ElementValue[0].ProbabilityOfPrecipitation,
                                temp: currentTemp ? currentTemp.ElementValue[0].Temperature : 'N/A',
                                apparentTemp: currentApparentTemp ? currentApparentTemp.ElementValue[0].ApparentTemperature : 'N/A',
                                weather: currentWx ? currentWx.ElementValue[0].Weather : 'N/A',
                                weatherCode: currentWx ? currentWx.ElementValue[0].WeatherCode : 'N/A'
                            };
                        });

                        return { name: location.LocationName, forecasts };
                    });
                    this.locations = processedLocations;
                },
                renderChart() {
                    if (this.chartInstance) {
                        this.chartInstance.destroy(); // éŠ·æ¯€èˆŠåœ–è¡¨
                    }

                    const ctx = document.getElementById('weatherChart').getContext('2d');
                    if (!ctx || !this.currentLocationData.forecasts.length) return;

                    const forecasts = this.currentLocationData.forecasts;

                    this.chartInstance = new Chart(ctx, {
                        type: 'bar',
                        data: {
                            labels: forecasts.map(f => this.formatTime(f.startTime)),
                            datasets: [
                                {
                                    type: 'line',
                                    label: 'æº«åº¦ (Â°C)',
                                    data: forecasts.map(f => f.temp),
                                    borderColor: 'rgba(255, 99, 132, 1)',
                                    backgroundColor: 'rgba(255, 99, 132, 0.2)',
                                    yAxisID: 'y-temp',
                                    tension: 0.3,
                                },
                                {
                                    type: 'line',
                                    label: 'é«”æ„Ÿæº«åº¦ (Â°C)',
                                    data: forecasts.map(f => f.apparentTemp),
                                    borderColor: 'rgba(255, 159, 64, 1)',
                                    backgroundColor: 'rgba(255, 159, 64, 0.2)',
                                    yAxisID: 'y-temp',
                                    tension: 0.3,
                                    borderDash: [5, 5],
                                },
                                {
                                    type: 'bar',
                                    label: 'é™é›¨æ©Ÿç‡ (%)',
                                    data: forecasts.map(f => f.pop),
                                    backgroundColor: 'rgba(54, 162, 235, 0.5)',
                                    borderColor: 'rgba(54, 162, 235, 1)',
                                    yAxisID: 'y-pop',
                                },
                            ]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            interaction: {
                                mode: 'index',
                                intersect: false,
                            },
                            scales: {
                                'y-temp': {
                                    type: 'linear',
                                    position: 'left',
                                    title: {
                                        display: true,
                                        text: 'æº«åº¦ (Â°C)'
                                    }
                                },
                                'y-pop': {
                                    type: 'linear',
                                    position: 'right',
                                    min: 0,
                                    max: 100,
                                    title: {
                                        display: true,
                                        text: 'é™é›¨æ©Ÿç‡ (%)'
                                    },
                                    grid: {
                                        drawOnChartArea: false, // é¿å…æ ¼ç·šé‡ç–Š
                                    }
                                }
                            }
                        }
                    });
                },
                // è¼”åŠ©å‡½å¼ï¼šæ ¼å¼åŒ–æ™‚é–“
                formatTime(dateTimeStr) {
                    const date = new Date(dateTimeStr);
                    return date.toLocaleTimeString('zh-TW', { hour: '2-digit', minute: '2-digit', hour12: false });
                },
                formatDate(dateTimeStr) {
                    const date = new Date(dateTimeStr);
                    return date.toLocaleDateString('zh-TW', { month: '2-digit', day: '2-digit' });
                },
                // è¼”åŠ©å‡½å¼ï¼šæ ¹æ“šå¤©æ°£ä»£ç¢¼å›å‚³ Bootstrap Icon class
                getWeatherIconClass(code) {
                    const codeNum = parseInt(code);
                    if ([15, 16, 17, 18, 21, 22, 33, 34, 35, 36, 41].includes(codeNum)) {
                        return 'bi bi-cloud-lightning-rain-fill'; // é›·é›¨
                    }
                    if ([8, 9, 10, 11, 12, 13, 14, 19, 20, 29, 30, 31, 32, 38, 39].includes(codeNum)) {
                        return 'bi bi-cloud-drizzle-fill'; // é›¨
                    }
                    if ([24, 25, 26, 27, 28].includes(codeNum)) {
                        return 'bi bi-cloud-fog2-fill'; // éœ§
                    }
                    if ([4, 5, 6, 7].includes(codeNum)) {
                        return 'bi bi-clouds-fill'; // å¤šé›²
                    }
                    if (codeNum === 1) {
                        return 'bi bi-brightness-high-fill'; // æ™´
                    }
                    if ([2, 3].includes(codeNum)) {
                        return 'bi bi-cloud-sun-fill'; // æ™´æ™‚å¤šé›²
                    }
                    return 'bi bi-cloud-fill'; // é è¨­ï¼šé™°
                }
            },
            mounted() {
                // Vue å¯¦ä¾‹æ›è¼‰å¾Œï¼Œè‡ªå‹•ç²å–è³‡æ–™
                this.fetchWeatherData();
            }
        }).mount('#app');

    </script>

</body>

</html>